Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.piAllSettled = void 0;

const piAllSettled = (iterable, concurrency = Infinity) => {
  if (!Number.isSafeInteger(concurrency) && concurrency !== Infinity || concurrency < 1) {
    throw new TypeError('`concurrency` argument must be a number >= 1');
  }

  return {
    async *[Symbol.asyncIterator]() {
      const pool = new Set();
      const iterator = iterable[Symbol.iterator]();
      let results = [];
      let isDone = false;

      const next = async () => {
        const iteration = iterator.next();

        if (iteration.done === true) {
          isDone = true;
          return;
        }

        let maybePromise;

        try {
          maybePromise = iteration.value();
          pool.add(maybePromise);
          const result = await maybePromise;
          results.push({
            status: 'fulfilled',
            value: result
          });
        } catch (error) {
          results.push({
            status: 'rejected',
            reason: error
          });
        } finally {
          pool.delete(maybePromise);
        }
      };

      for (let i = 0; i < concurrency; i++) {
        next();

        if (isDone) {
          break;
        }
      }

      while (pool.size !== 0) {
        try {
          await Promise.race(pool.values());
        } catch {} finally {
          for (const result of results) {
            yield result;

            if (!isDone) {
              void next();
            }
          }

          results = [];
        }
      }
    }

  };
};

exports.piAllSettled = piAllSettled;